\chapter{Übung Streams}

\section{Aufgabe 1}
Gegeben sei folgende Methode. Schreiben Sie die Methode unter Verwendung von
Streams derart um, dass darin weder eine explizite Iteration, noch eine
if-Anweisung vorkommt

\begin{lstlisting}
public static List<String> m1(Collection<String> woerter) {
  List<String> ergebnis = new ArrayList<>();
  for (String wort : woerter) {
    if (wort.length() >= 5) {
      String s = wort.substring(wort.length() / 2);
      if (s.charAt(0) >= 'a') {
        ergebnis.add(s);
      }
    }
  }
  return ergebnis;
}
\end{lstlisting}

\section{Aufgabe 2}
Schauen Sie sich die API-Dokumentation der Klasse \lstinline{OptionalInt}, insbesondere der
Methode \lstinline{ifPresent} an. Ändern Sie dann das folgende Code-Stück derart, dass es
bei gleichem Verhalten keine if-Anweisung mehr enthält. Die Variable is ist vom
Typ IntStream.

\begin{lstlisting}
OptionalInt zahlOpt = is
        .filter(n -> n % 2 == 0)
        .findAny();
if(zahlOpt.isPresent()){
  int zahl = zahlOpt.getAsInt();
  System.out.println(zahl *zahl);
}
\end{lstlisting}

\section{Aufgabe 3}
Schauen Sie sich die API-Dokumentation der Schnittstelle \lstinline{LongStream},
insbesondere der Methode \lstinline{takeWhile} an. Geben Sie unter Verwendung der Methode
\lstinline{LongStream fibonaccis()} aus dem Code-Beispiel der Vorlesung einen Ausdruck an,
der den Stream aller Fibonacci-Zahlen liefert, die mathematisch korrekt
berechnet werden (d. h. bei denen es zu keinen Überlauf kommt).

\section{Aufgabe 4}
Es sei s eine Variable des Typs \lstinline{Set<Integer>}.
\begin{enumerate}
    \item Geben Sie einen Ausdruck an, der die Summe aller Elemente der Menge s
          berechnet, die geradzahlig sind.
    \item Geben Sie einen Ausdruck des Typs \lstinline{IntStream} an, der alle natürlichen Zahlen
          enthält bis einschließlich 100, die nicht in der Menge s enthalten sind.
\end{enumerate}

\section{Aufgabe 5}
Geben Sie einen Ausdruck des Typs \lstinline{IntStream} an, der folgende Elemente enthält:
0, 1, 3, 7, 15, 31, ...

\section{Aufgabe 6}
Realisieren Sie eine Methode boolean \lstinline{istPalindrom(String s)} ohne Verwendung von
Schleifen, if-Anweisungen und Rekursion.

\section{Aufgabe 7}
Gegeben sei das folgende Code-Stück? Die Variable zeilen ist vom Typ
\lstinline{Stream<String>}.

\begin{lstlisting}
zeilen
    .map(w -> new StringTokenizer(w))
    .filter(st -> st.hasMoreTokens())
    .map(st -> st.nextToken())
    .filter(s -> s.length() >= 5)
    .findFirst();
\end{lstlisting}

\begin{enumerate}
    \item Was berechnet der Ausdruck?
    \item Jemand behauptet, das Code-Stück sei völlig ineffizient und würde, wenn zeilen
          einen unendlichen Stream enthält, überhaupt nicht terminieren. Er begründet
          dies damit, dass durch die erste Anwendung von map für alle Elemente des
          Streams zunächst ein StringTokenizer erzeugt wird. Ändern Sie das Code-Stück
          derart, dass durch Bildschirmausgaben dokumentiert wird, dass die Person
          Unrecht hat und nur soviele StringTokenizer erzeugt werden, wie für die
          Funktion des Code-Stücks benötigt werden.
\end{enumerate}