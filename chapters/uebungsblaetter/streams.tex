\chapter{Übung Streams}

\section{Aufgabe 1}
Gegeben sei folgende Methode. Schreiben Sie die Methode unter Verwendung von
Streams derart um, dass darin weder eine explizite Iteration, noch eine
if-Anweisung vorkommt

\begin{lstlisting}
public static List<String> m1(Collection<String> woerter) {
  List<String> ergebnis = new ArrayList<>();
  for (String wort : woerter) {
    if (wort.length() >= 5) {
      String s = wort.substring(wort.length() / 2);
      if (s.charAt(0) >= 'a') {
        ergebnis.add(s);
      }
    }
  }
  return ergebnis;
}
\end{lstlisting}

\section{Aufgabe 2}
Schauen Sie sich die API-Dokumentation der Klasse OptionalInt, insbesondere der
Methode ifPresent an. Ändern Sie dann das folgende Code-Stück derart, dass es
bei gleichem Verhalten keine if-Anweisung mehr enthält. Die Variable is ist vom
Typ IntStream.

\begin{lstlisting}
OptionalInt zahlOpt = is
        .filter(n -> n % 2 == 0)
        .findAny();
if(zahlOpt.

isPresent()){
int zahl = zahlOpt.getAsInt();
System.out.

println(zahl *zahl);
}
\end{lstlisting}

\section{Aufgabe 3}
Schauen Sie sich die API-Dokumentation der Schnittstelle LongStream,
insbesondere der Methode takeWhile an. Geben Sie unter Verwendung der Methode
LongStream fibonaccis() aus dem Code-Beispiel der Vorlesung einen Ausdruck an,
der den Stream aller Fibonacci-Zahlen liefert, die mathematisch korrekt
berechnet werden (d. h. bei denen es zu keinen Überlauf kommt).

\section{Aufgabe 4}
Es sei s eine Variable des Typs Set<Integer>.
\begin{enumerate}
    \item Geben Sie einen Ausdruck an, der die Summe aller Elemente der Menge s
          berechnet, die geradzahlig sind.
    \item Geben Sie einen Ausdruck des Typs IntStream an, der alle natürlichen Zahlen
          enthält bis einschließlich 100, die nicht in der Menge s enthalten sind.
\end{enumerate}

\section{Aufgabe 5}
Geben Sie einen Ausdruck des Typs IntStream an, der folgende Elemente enthält:
0, 1, 3, 7, 15, 31, ...

\section{Aufgabe 6}
Realisieren Sie eine Methode boolean istPalindrom(String s) ohne Verwendung von
Schlei- fen, if-Anweisungen und Rekursion.

\section{Aufgabe 7}
Gegeben sei das folgende Code-Stück? Die Variable zeilen ist vom Typ
Stream<String>.

\begin{lstlisting}
zeilen
    .map(w -> new StringTokenizer(w))
    .filter(st -> st.hasMoreTokens())
    .map(st -> st.nextToken())
    .filter(s -> s.length() >= 5)
    .findFirst();
\end{lstlisting}

\begin{enumerate}
    \item Was berechnet der Ausdruck?
    \item Jemand behauptet, das Code-Stück sei völlig ineffizient und würde, wenn zeilen
          einen un- endlichen Stream enthält, überhaupt nicht terminieren. Er begründet
          dies damit, dass durch die erste Anwendung von map für alle Elemente des
          Streams zunächst ein StringTokenizer erzeugt wird. Ändern Sie das Code-Stück
          derart, dass durch Bildschirmausgaben dokumentiert wird, dass die Person
          Unrecht hat und nur soviele StringTokenizer erzeugt werden, wie für die
          Funktion des Code-Stücks benötigt werden.
\end{enumerate}