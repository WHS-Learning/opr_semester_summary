\chapter{Ein- und Ausgabe}

\section{InputStream}
\label{inputstream}

Der \lstinline{InputStream} ist die Oberklasse und Abstraktion alelr
byteorientierten Eingabeströme. Es gibt nur zwei Methoden zum Lesen von Bytes:
\begin{itemize}
    \item \lstinline{int read()} liest \textit{ein} Byte
    \item \lstinline{int read(byte[])} liest mehrere Bytes, Ergebniswert hat eine andere
          Bedeutung als der von \lstinline{read()}
\end{itemize}

Der Rückgabewert der \lstinline{read()} Methode gibt den gelesenen Byte zurück.
Dieser kann einen Wert zwischen 0 und 255 (dem gelesenen Byte) sein. Ein
Rückgabewert von -1 signalisiert, dass das Ende des Streams erreicht wurde und
keine weiteren Bytes verfügbar sind. Es wird also keine Fehlermeldung geworfen,
wenn das Ende der Datei erreicht wurde. Wenn bei dem Lesen allerdings ein
Fehler auftritt, wird eine \lstinline{IOException} geworfen.

\begin{lstlisting}[language=Java, caption={Beispiel für InputStream}]
InputStream is = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5});

int b = is.read();
ArrayList<Integer> content = new ArrayList<>();

while (b != -1) {
    content.add(b);
}
\end{lstlisting}

Das einzelne Lesen von Bytes aus einen \lstinline{InputStream} ist sehr
ineffizient. Dateien können sehr groß werden, schnell auch mehrere Gigabyte
groß. Dies entspricht millionen von \lstinline{read()} aufrufen und damit
millionen von \texttt{I/O}-Zugriffen. Aufgrunddessen ist die einfache
\lstinline{read()} Methode in \lstinline{InputStreams} oft eine schlechte
lösung. Abhilfe schafft hier die Klasse \lstinline{BufferedInputStream}.

\subsection{BufferedInputStream}

Der BufferedInputStream kapselt einen InputStream und liest intern aus diesen
Blockweise über die Methode
\lstinline{read(byte[])}. Hier ist die Methode \lstinline{read()} effizient und
kann gut genutzt werden.

\subsection{ByteArrayInputStream}

Dies ist beispielsweise essenziell für das Schreiben von Testklassen, da diese
niemals direkt von externen Dateien abhängen sollten, um in sich geschlossen
und reproduzierbar zu sein.

\section{Reader}

Ähnlich wie der \nameref{inputstream} bietet der Reader zwei Methoden zum Lesen von Zeichen:
\begin{itemize}
    \item \lstinline{int read()} liest \textit{ein} Zeichen
    \item \lstinline{int read(char[])} liest mehrere Zeichen, Ergebniswert hat eine andere
          Bedeutung als der von \lstinline{read()}
\end{itemize}

Auch hier ist die Methode \lstinline{read()} für relativ große Datenquellen
sehr ineffizient.

\subsection{BufferedReader}

Der BufferedReader kapselt einen Reader ein und liest intern auf diesem
blockweise. Die \lstinline{read()}-Methode ist in dieser Klasse durch das
interne Puffern auch für einzelne Zeichenlesevorgänge effizient.

Der BufferedReader enthält außerdem die Methode \lstinline{String readLine()}
um eine ganze Zeile zu lesen. Dies kann auch der gesamte Inhalt der Datenquelle
sein. Außerdem enthält er die Methode \lstinline{Stream<String> lines()} um
einen Stream aller Zeilen zu erstellen.

\subsection{StringReader}

Die Klasse StringReader eignet sich sehr gut um Methoden mit Reader-Parametern
zu testen.

\section{Codierung}

Es gibt viel mehr Zeichen als Bytes. Deshalb müssen einige Zeichen durch
mehrere Bytes repräsentiert werden. Eine Zeichencodierung beschreibt die Art
der Codierung von Zeichen durch Bytes. Die am häufigsten verwendete Codierung
ist UTF-8. Die meisten westeuropäischen Zeichen werden hier durch ein Byte
dargestellt. Alle anderen Zeichen durch 2 bis 4 Byte. In UTF-16 werden alle
Zeichen durch mindestens zwei Byte dargestellt.

Um die Codierung eines InputStreams anzugeben, hat sein Konstruktor einen
zweiten Parameter. Über den \nameref{chap:aufzaehlungstypen}
\lstinline{StandardCharsets} kann hier dann die erwünschte Codierung angegeben
werden.

\begin{lstlisting}[language=Java, caption={Beispiel für Codierten InputStream}]
ByteArrayInputStream byteStream = new ByteArrayInputStream("Test mit ÄÖÜ".getBytes(StandardCharsets.UTF_8));
Reader reader = new InputStreamReader(byteStream, StandardCharsets.UTF_8);
StringBuilder result = new StringBuilder();
int character;

try {
    while ((character = reader.read()) != -1) {
    result.append((char) character);
    }
} finally {
    reader.close();
}
\end{lstlisting}

Verfügbare StandardCharsets sind:

\begin{itemize}
    \item \textbf{ISO\_8859\_1}
    \item \textbf{US\_ASCII}
    \item \textbf{UTF\_16}
    \item \textbf{UTF\_16BE}
    \item \textbf{UTF\_16LE}
    \item \textbf{UTF\_8}
\end{itemize}

Die Codierung eines \lstinline{Readers} kann nicht geändert werden, da dieser
bereits Zeichen liefert und eben keine Bytes. Allerdings kann über die
Instanzmethode \lstinline{byte[] getBytes()} der String Klasse die Codierung
angepasst werden:

\begin{lstlisting}[language=Java, caption={Beispiel für String Codierung ändern}]
String string = "examplestring";
byte[] bytes = string.getBytes();

String asciiEncodedString = new String(bytes, StandardCharsets.US_ASCII);

System.out.println(asciiEncodedString); 

String utf8EncodedString = new String(bytes, StandardCharsets.UTF_8);

System.out.println(utf8EncodedString);  

String utf16EncodedString = new String(bytes, StandardCharsets.UTF_16);

System.out.println(utf16EncodedString); 
\end{lstlisting}

Wenn bytes in einer Tabelle nicht gefunden werden, werden diese über ein ?
repräsentiert. Wird eine falsche Codierung angewandt, so werden die Zeichen
anders interpretiert. Die Methode \lstinline{getBytes()} übersetzt den String
standardmäßig in die Standardcodierung der JVM, welche in Deutschland idr.
UTF-8 is. Diese Codierung kann allerdings über den Parameter explizit angegeben
werden.

\section{OutputStream}

Der OutputStream ist die Oberklasse aller Byteorientierten Ausgabeströmen. Er
besitzt zwei Methoden:
\begin{itemize}
    \item \lstinline{write(int)}
    \item \lstinline{write(byte[])}
\end{itemize}

Die Methode \lstinline{write(int)} istbei externen Datensenken potentiell
Ineffizient. Aufgrunddessen gibt es hier die Klasse BufferedOutputStream.

\begin{lstlisting}[language=Java, caption={Beispiel für OutputStream}]
OutputStream bs = new ByteArrayOutputStream();

byte[] bytes = new byte[]{1, 2, 3, 4, 5}

for (byte b : bytes) {
    bs.write(b);
}
\end{lstlisting}

\subsection{BufferedOutputStream}

Der BufferedOutputStream kapselt einen OutputStream und schreibt dort
blockweise hinen. Die \lstinline{write(int)} Methode dieser Klasse ist auch für
externe Datensenken effizient.

\subsection{ByteArrayOutputStream}

der ByteArrayOutputStream eignet sich zum Testen von Methoden mit
OutputStream-Parametern.